use crate::color::Color;

pub struct TemplateGenerator {
    colors: Vec<Color>,
    strip_hash: bool,
}

impl TemplateGenerator {
    pub fn new(colors: Vec<Color>, strip_hash: bool) -> Self {
        TemplateGenerator { colors, strip_hash }
    }

    fn get_color_string(&self, color: &Color) -> String {
        if self.strip_hash {
            color.to_hex_stripped()
        } else {
            color.to_hex()
        }
    }

    pub fn generate_shell_template(&self) -> String {
        let mut output = String::new();
        output.push_str("#!/bin/bash\n");
        output.push_str("# Pywal-style color variables generated with haishoku algorithm\n\n");

        output.push_str(&format!(
            "export background='{}'\n",
            self.get_color_string(&self.colors[0])
        ));
        output.push_str(&format!(
            "export foreground='{}'\n",
            self.get_color_string(self.colors.get(15).unwrap_or(&self.colors[7]))
        ));
        output.push_str(&format!(
            "export cursor='{}'\n",
            self.get_color_string(self.colors.get(15).unwrap_or(&self.colors[7]))
        ));

        for (i, color) in self.colors.iter().enumerate() {
            output.push_str(&format!(
                "export color{}='{}'\n",
                i,
                self.get_color_string(color)
            ));
        }

        output
    }

    pub fn generate_css_template(&self) -> String {
        let mut output = String::new();
        output.push_str("/* Pywal-style CSS variables generated with haishoku algorithm */\n");
        output.push_str(":root {\n");

        output.push_str(&format!(
            "  --background: {};\n",
            self.get_color_string(&self.colors[0])
        ));
        output.push_str(&format!(
            "  --foreground: {};\n",
            self.get_color_string(self.colors.get(15).unwrap_or(&self.colors[7]))
        ));
        output.push_str(&format!(
            "  --cursor: {};\n",
            self.get_color_string(self.colors.get(15).unwrap_or(&self.colors[7]))
        ));

        for (i, color) in self.colors.iter().enumerate() {
            output.push_str(&format!(
                "  --color{}: {};\n",
                i,
                self.get_color_string(color)
            ));
        }

        output.push_str("}\n");
        output
    }

    pub fn generate_json_template(&self) -> String {
        let mut output = String::new();
        output.push_str("{\n");
        output.push_str("    \"colors\": {\n");

        for (i, color) in self.colors.iter().enumerate() {
            let comma = if i == self.colors.len() - 1 { "" } else { "," };
            // Always use stripped hex for JSON to use with thorn (without # prefix)
            output.push_str(&format!(
                "        \"color{}\": \"{}\"{}\n",
                i,
                color.to_hex_stripped(),
                comma
            ));
        }

        output.push_str("    }\n");
        output.push_str("}\n");
        output
    }

    pub fn generate_xresources_template(&self) -> String {
        let mut output = String::new();
        output.push_str("! Pywal-style Xresources generated with haishoku algorithm\n");
        output.push_str("! Use with: xrdb -merge colors.Xresources\n\n");

        output.push_str(&format!(
            "*background: {}\n",
            self.get_color_string(&self.colors[0])
        ));
        output.push_str(&format!(
            "*foreground: {}\n",
            self.get_color_string(self.colors.get(15).unwrap_or(&self.colors[7]))
        ));
        output.push_str(&format!(
            "*cursorColor: {}\n",
            self.get_color_string(self.colors.get(15).unwrap_or(&self.colors[7]))
        ));

        for (i, color) in self.colors.iter().enumerate() {
            output.push_str(&format!("*color{}: {}\n", i, self.get_color_string(color)));
        }

        output
    }

    pub fn generate_scss_template(&self, wallpaper_path: &str) -> String {
        let mut output = String::new();
        output.push_str("// SCSS Variables\n");
        output.push_str("// Generated by 'wal'\n");

        output.push_str(&format!("$wallpaper: \"{}\";\n\n", wallpaper_path));

        output.push_str("// Special\n");
        output.push_str(&format!("$background: {};\n", self.colors[0].to_hex()));
        output.push_str(&format!(
            "$foreground: {};\n",
            self.colors.get(15).unwrap_or(&self.colors[7]).to_hex()
        ));
        output.push_str(&format!(
            "$cursor: {};\n\n",
            self.colors.get(15).unwrap_or(&self.colors[7]).to_hex()
        ));

        output.push_str("// Colors\n");
        for (i, color) in self.colors.iter().enumerate() {
            output.push_str(&format!("$color{}: {};\n", i, color.to_hex()));
        }

        // Add rgba pop color (using color13 with 0.6 alpha)
        if self.colors.len() >= 14 {
            let color13 = &self.colors[13];
            output.push_str(&format!(
                "$rgbapop: rgba({},{},{},0.6);\n",
                color13.r, color13.g, color13.b
            ));
        }

        output
    }
}